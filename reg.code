#fast read, , 57 sec for a 3G data
regdata<-fread("Y_X_dif_lags.txt")
summary(regdata)


#fast read,  6 mins for a 3G data
regdata<-read.table(file="Y_X_dif_lags.txt",header=T)
summary(regdata)

plot(regdata$lag.1,regdata$difF1D)



regdata<- regdata[regdata$DATE>20030101,]




plot(regdata$bt1FcstDM.HG,regdata$ooF1D.HG,pch=".")
fit2<-lm(ooF1D.HG ~ bt1FcstDM.HG,data=regdata)
summary(fit2)


plot(regdata$bt1FcstDM.HG,regdata$ooF1D.HG)
fit2<-lm(ooF1D.HG ~ bt1FcstDM.HG,data=regdata)
summary(fit2)


source("~/myRFuncs/loadUtils.R")

################
## compute cv fcst
##
##


## noet that I do CV on full data,

cvFcst=cvfcst1( ooF1D ~ SP.CC.1 + SP.CC.2 + VX.CC.1 + JY.CC.1 + I((DX.CC.4 + DX.CC.5 + DX.CC.6 + DX.CC.7)), regdata, "DATE", lm, 50)

fit1<-lm( ooF1D ~ cvFcst$yhat,data=regdata)
summary(fit1)


#############################
###########################
getDOW <- function(DATE)
#date=20180711 
# sun=0, mon=1, tue=2,...
{
   MMDD=DATE%%10000
   YYYY=(DATE-MMDD) /10000
   DD=DATE%%10000%%100
   YYMM=(DATE-DD) /100
   MM=(MMDD-DD)/100

   year=YYYY
   month=MM
   day=DD

  # Implementation of the Gaussian algorithm to get weekday 0 - Sunday, ... , 7 - Saturday
  Y <- year
  Y[month<3] <- (Y[month<3] - 1)

  d <- day
  m <- ((month + 9)%%12) + 1
  c <- floor(Y/100)
  y <- Y-c*100
  dayofweek <- (d + floor(2.6*m - 0.2) + y + floor(y/4) + floor(c/4) - 2*c) %% 7
  return(dayofweek)
}
###########################
##########################





#########
OLSIntra



source("~/myRFuncs/OLSIntra.R")

OLSIntra(
PLCOScl~
#(jf.FOM+jf.FMC)
#jf.FMC:as.factor(SESSION)
#:ifelse(SESSION != "Europe",1,0)
constrain(CHGS120MScl,-1.5,1.5):as.factor(ASSET4)
+as.factor(ASSET4)
,sizeX=0.03,tcost=0.03,data=regdata
)


#####

#################################
##############################
### PerformanceAnalytics based on monthly rets
### drawdown and perf. statistics
############################
regdata<-read.table(file="monthly_ret.txt",header=T)
summary(regdata)

#convert date to R format
regdata$RDATE= as.Date(as.character(regdata$DATE), format = "%Y%m%d")
#must assign rowname as RDATE to get PA to work
rownames(regdata)=regdata$RDATE

#plot(regdata$RDATE,regdata$ret)

library(PerformanceAnalytics)

#more than one series
#charts.PerformanceSummary(regdata[,c(2,2)], geometric = FALSE,colorset=rich6equal)

# creats cumRet, ret and drawdown plots
# note that drawn down is in pct from peak value
charts.PerformanceSummary(regdata[,c("ret"),drop = FALSE], geometric = FALSE, colorset=rich6equal)


chart.CumReturns(regdata[,c("ret"),drop = FALSE], geometric = FALSE, colorset=rich6equal)
chart.Drawdown(regdata[,c("ret"),drop = FALSE], geometric = FALSE, colorset=rich6equal)


     ‘chart.BarVaR’
     ‘chart.Drawdown’

# display monthly ret table
t(table.CalendarReturns(regdata[,c("ret"),drop = FALSE],geometric = FALSE)/100)

# compute mean/std/skew/kurt type of ret stats
table.Stats( regdata[,c("ret"),drop = FALSE])

#this one is problematic
table.Drawdowns(regdata[,c("ret"),drop = FALSE])

findDrawdowns(regdata[,c("ret"),drop = FALSE], geometric = FALSE)


# http://cran.r-project.org/web/packages/PerformanceAnalytics/vignettes/PA-charts.pdf


##############################################
###################################################


##new method, works
x <- regdata1t9[,c(14,13,18,22,25:34,35:44,45:57)]
y <- regdata1t9[,c(16,15,19,20,21,17)]
cor(x,y)



## this is old method, not working in new R
###################
## all univariate R2s:
x <- regdata[c(3,23:46)]
y <- regdata[c(4,16:22)]
cor(x,y)
###################
## all univariate R2s:
x <- regdata[c(3,23:46)]
y <- regdata[c(4,16:22,50:79)]
cor(x,y)


#################################
## correlation of all numeric columns:
#
cor(Filter(is.numeric,regdata))
#
#################################


#########################
### then check sharpe ratio/shp for verifications


library(data.table)

# step 1: model
#fit2<-lm(ooF1D ~ 
#predKSVMAdjCapped + predKSVMFD2Capped
#I(0.000931252+ 0.421295077*predKSVMAdjCapped + 0.208473201*predKSVMFD2Capped)
#,data=regdataPost)
#summary(fit2)
#R2=summary(fit2)$r.squared

# a=0.3425375 #OLS
# a=0  # no FD2
#  a=0.4036707  # maxShp
 a=1000  # maxShp

fcst2 = regdata$predKSVMAdjCapped+a*regdataPost$predKSVMFD2Capped


fcst2=fit2$fitted 

R2=cor(regdata$ooF1D,fcst2)^2



# step 2: DATE and pnl
regdata$pnl=regdata$ooF1D*fcst2
df= as.data.frame(cbind(regdata$DATE,regdata$pnl))
names(df)=c("DATE","pnl")
# step 3: compute shp with data.table
# data table util is very fast
dt <- data.table(df)
setkey(dt,DATE) # this will sort by DATE invisibly
dfPort<-dt[,list(ppl=sum(pnl),count=.N),by=DATE]
mean=mean(dfPort$ppl)
sd=sd(dfPort$ppl)
shp=mean/sd
shp


PPL2=dfPort$ppl
pcShp=mean(regdata$pnl)/sd(regdata$pnl)

# R2 and shp
#cat("R2=",round(R2,digits=7)," mean=",round(mean,digits=7), " std=",round(sd,digits=7)," shp=",round(shp,digits=5),"\n")
cat("R2=",round(R2,digits=7)," mean=",round(mean,digits=7), " std=",round(sd,digits=7)," shp=",round(shp,digits=5), " pcShp=",pcShp,"divNum=", round(shp/pcShp,digits=2), "\n")

#########################################
#########################################



####################################
####extract a subset from regdata
#################
subset(regdataPost,select=c("SYM","DATE","GAP","O.1","H.1","L.1","C.1","O.2","H.2","L.2","C.2", "O.3","H.3","L.3","C.3", "O.4","H.4","L.4","C.4"),SYM=="ES" & DATE==20150219)
      SYM     DATE       GAP       O.1      H.1       L.1      C.1      O.2      H.2       L.2      C.2       O.3      H.3       L.3       C.3      O.4      H.4       L.4      C.4
97955  ES 20150219 -0.339477 -0.240463 0.084869 -0.424346 -0.02829 0.139787 0.670979 -0.027957 0.517213 -0.165934 0.013828 -0.553112 -0.373351 0.109021 0.572362 -0.068138 0.517851

## find out row number in dataframe
which(regdataPost$SYM=="ES" & regdataPost$DATE==20150219)
[1] 34664


###########################


####################
############
## CART tree

# tree
library(tree)

mytree <- tree(F120M ~ LAG.15t240, mindev=0.0, mincut = (length(regdata[,1])/40), regdata)
mytree

#tree yhat
yhatTree<- predict(mytree,regdata)
plot(yhatTree,regdata$F120M,pch='.')
fit1<-lm( F120M ~ yhatTree,data=regdata)
summary(fit1)


# plot yhat vx x
plot(regdata$DTR,yhatTree)


########################
##########################




#######################################
### scale oonly certain columns
#######################################

standarize <- function(x)
#subtract mean and divide by sd
{
  m=mean(x)
  std=sd(x)
  x<- (x -m)/std
}


data1<- as.data.frame(matrix(1:20,nrow=5,ncol=4))
names(data1)=c("x1","x2","x3","x4")
data1[5,4]=30

data1Norm=data1[c("x2","x3","x4")]
whichcols= match(c("x3","x4"),names(data1Norm))


#method 1: scale only columns x3 and x4
data1Norm[,whichcols]=scale(data1Norm[,whichcols])
data1Norm

## method 2: another method with own function, can apply other functions as well
data1Norm[,whichcols]=lapply(data1Norm[whichcols],standarize)
data1Norm
###########################
###########################







#######################################################################
######### lekprofile:   NeuralNetTools trick to make lekprofile work with neuralnet
#######################################################################
#######################################################################
library(neuralnet)
library(nnet)
library(NeuralNetTools)
 
# neuralnet mod
mod1 <- neuralnet(Y1 ~ X1 + X2 + X3, data = neuraldat, hidden = 5)
 
# nnet mod, get weights from neuralnet
modwts <- neuralweights(mod1)
modwts <- unlist(modwts$wts)
mod2 <- nnet(Y1 ~ X1 + X2 + X3, data = neuraldat, size = 5, Wts = modwts,  maxit = 0, linout = T)
 
# lek
lekprofile(mod2)
 
# compare model predictions
mod1_res <- mod1$net.result[[1]]
mod2_res <- predict(mod2)
plot(mod1_res, mod2_res)
unique(mod1_res- mod2_res) # results are identical

#################################
##################################


----- lekprofile for NN model (from net2 object)
#save(net2, file = "net2.Rdata")
load("net2.Rdata")
#save everything
save.image(file = "all.Rdata")


library(neuralnet)
library(nnet)
library(NeuralNetTools)
 
# neuralnet mod
#mod1 <- neuralnet(Y1 ~ X1 + X2 + X3, data = neuraldat, hidden = 5)
 

# nnet mod, get weights from neuralnet
net3=net2

net3$weights[[1]]= net3$weights[[8]] ## I assign rep=8(I want 8) to rep=1,
modwts =neuralweights(net3) ## neuralweights func will extract first weights
modwts <- unlist(modwts$wts)


regdataPre=net3$data
# run nnet with neuralnbet weights, but don't iterate
modnnet <- nnet(ooF1DScl ~ GAP.1 + HC.1 + LC.1 + AbsOO.3 + AEMAOO, data = regdataPre, size = 3, Wts = modwts,  maxit = 0, linout = T)

 
# lek
lekprofile(modnnet)


### adjust x and y axis limits
## The function also returns a ggplot2 object that can be further modified. 
p1 = lekprofile(modnnet)
#class(p1)
# [1] "gg"     "ggplot"
library(ggplot2)
### adjust x and y axis limits
p1+scale_x_continuous(limits = c(-4, 4))+scale_y_continuous(limits = c(0.42,0.58))




## another theme
p1 + theme_bw() +
   scale_colour_brewer(palette="PuBu") +
   scale_linetype_manual(values=rep('dashed',6)) +
   scale_size_manual(values=rep(1,6))


#output values
head( lekprofile(modnnet,val_out=T))




# save to pdf
pdf("lek_net2.pdf")
lekprofile(modnnet)
dev.off()

pdf("lek_net2_ggplot.pdf")
p1+scale_x_continuous(limits = c(-4, 4))+scale_y_continuous(limits = c(0.42,0.58))
dev.off()


# compare model predictions
net2_res <- net2$net.result[[8]]
modnnet_res <- predict(modnnet)
#plot(mod1_res, modnnet_res)
unique(net2_res- modnnet_res) # results are identical


############################################################
#############################################################







###################################
#####3.4). various neural networks R packages
##############################
neuralnet, nnet, RSNNS, deepnet, h2o on the simple regression and interaction example.
/home/jgeng/projects/PortaraFVOO/TEST1_OO_HILOs/TEST3_FV_revisited_scaleByFullSampleStd/TEST1_outSampleTest/TEST1_nnetExamples
###############################
##########################




#########################
##########  use caret CV
##########
###############

2). use caret's CV to pick best number of neurons

library(caret)


#10-fold CV, repeat only once
ctrl <- trainControl(method = "cv", 
                      repeats = 1,
       	              number=10,
                      #seeds = seeds
		      )

#note caret use layer1/2/3, so don't double specify hidden
paragrid <- expand.grid(.layer1 = c(1,2,3,4,5,6,8,10,15,20), .layer2 = 0, .layer3 = 0)


caret.nn <- train(ooF1DScl ~OO.1+OO.3, 
                   data = regdataPre, 
                   method = "neuralnet", 
                   algorithm = 'rprop+', 
                   #learningrate = 0.25, 
		   threshold=0.01,
                   rep=1,		 
                   #hidden = 3, 
                   trControl = ctrl,
                   linear.output=TRUE,
                   tuneGrid = paragrid
                    )


caret.nn

trellis.par.set(caretTheme())
plot(caret.nn)

plot(caret.nn,metric = "RsquaredSD")


## for plot: RMSE and RMSESD
plot(caret.nn$results$layer1,caret.nn$results$RMSE,type="b",pch=1,lty=1,ylim=c(0.0,0.2))
lines(caret.nn$results$layer1,caret.nn$results$RMSESD*10,type="b",pch=4,lty=4,col="red")
#legend(0.75, 0.0006, c("0.875", "0.95","0.99"), pch= c(1, 4,5),col=c("black","red","blue"))
#title("R2(ooF1D~ooP1D) for ema speeds")


## for plot: R2 and CVR2
plot(caret.nn$results$layer1,caret.nn$results$Rsquared,type="b",pch=1,lty=1,ylim=c(0.0,0.02))
lines(caret.nn$results$layer1,caret.nn$results$RsquaredSD,type="b",pch=4,lty=4,col="red")
#legend(0.75, 0.0006, c("0.875", "0.95","0.99"), pch= c(1, 4,5),col=c("black","red","blue"))
#title("R2(ooF1D~ooP1D) for ema speeds")
# to see line type: ?plot.default.


##########################
## compute out-sample R2 for each parameter


trainSet<- model.matrix(~ OO.1+OO.3-1, regdataPre)
testSet<- model.matrix(~ OO.1+OO.3-1, regdataPost)

scale=max(regdata$ooF1D)-min(regdata$ooF1D)
min=min(regdata$ooF1D)


hiddenList<- c(1,2,3,4,5,6,8,10,12,15,17,20)

ns=rep(0,length(hiddenList))
R2Ins=rep(0,length(hiddenList))
R2Outs=rep(0,length(hiddenList))

count=0;
#for ( n in hiddenList) 
for ( n in c(15)) 
{
   count=count+1;
   net2 <- neuralnet(ooF1DScl~OO.1+OO.3,regdataPre, hidden=n, threshold=0.01,rep=3,linear.output=TRUE)

   # use the best model among 3 reps
   best=which.min(as.vector(net2$result.matrix["error",]))

   ### in-sample
   netIn <- compute(net2, trainSet,rep=best)
   predNNETIn<- netIn$net.result
   # scale back
   predNNETIn<-predNNETIn*scale+min
   R2In=sign(cor(predNNETIn,regdataPre$ooF1D))*cor(predNNETIn,regdataPre$ooF1D)^2

   ### out-sample
   netOut <- compute(net2, testSet,rep=best)
   predNNET<- netOut$net.result
   #scale back
   predNNET<-predNNET*scale+min
   R2Out=sign(cor(predNNET,regdataPost$ooF1D))*cor(predNNET,regdataPost$ooF1D)^2
   print(paste(n," ",R2In," ",R2Out))

   ns[count]=n;
   R2Ins[count]=R2In
   R2Outs[count]=R2Out
}


allR2s=as.data.frame(cbind(ns,R2Ins,R2Outs))
allR2s


## for plot: in-R2 and out-R2
plot(allR2s$ns,allR2s$R2Ins,type="b",pch=1,lty=1,ylim=c(0.0,0.02))
lines(allR2s$ns,allR2s$R2Outs,type="b",pch=4,lty=4,col="red")
#legend(0.75, 0.0006, c("0.875", "0.95","0.99"), pch= c(1, 4,5),col=c("black","red","blue"))
#title("R2(ooF1D~ooP1D) for ema speeds")
# to see line type: ?plot.default.


#############################################
###############################################
############################################


#############################
######## neuralnet example
########
#############################


library(neuralnet)


scale=max(regdata$ooF1D)-min(regdata$ooF1D)
min=min(regdata$ooF1D)


set.seed(31)

regdata$ooF1DScl=scaleZero2One(regdata$ooF1D)

regdata$AbsOO.3<- abs(regdata$OO.3)

regdataPre<- regdata[regdata$DATE <= 20070101,]
regdataPost<- regdata[regdata$DATE > 20070101,]


plot(regdataPre$OO.1,regdataPre$ooF1D)
plot(regdataPost$OO.1,regdataPost$ooF1D)

## neuralnet

# test 1:   1 layer, X neurons
#set.seed(17)


#norm.fun = function(x){(x - min(x))/(max(x) - min(x))}
#cols=c("OO.1","AbsOO.3","ooF1DScl")
#regdataPreNorm =  apply(regdataPre[cols], 2,norm.fun)
#regdataPostNorm =  apply(regdataPost[cols], 2,norm.fun)



net1 <- neuralnet(ooF1DScl~OO.1+AbsOO.3,regdataPre, hidden=c(4), threshold=0.01,rep=100,linear.output=TRUE,stepmax = 1e+05,lifesign = "full")
#,lifesign.step=1)


## if rep >1, check all R2s from each fut
rep=90
allFits<- as.data.frame(matrix(unlist(net1$net.result),ncol=rep))
cor(allFits,regdataPre$ooF1D)^2






# activation function
net1$act.fct
net1$weight
plot(net1)

trainSet<- model.matrix(~ OO.1+AbsOO.3-1, regdataPre)
testSet<- model.matrix(~ OO.1+AbsOO.3-1, regdataPost)

scale=max(regdata$ooF1D)-min(regdata$ooF1D)
min=min(regdata$ooF1D)




### in-sample
netIn <- compute(net1, trainSet,rep=1)
predNNETIn<- netIn$net.result
# scale back
predNNETIn<-predNNETIn*scale+min

plot(predNNETIn,regdataPre$ooF1D)
fit2<-lm(ooF1D ~ predNNETIn,data=regdataPre)
summary(fit2)




### out-sample
netOut <- compute(net1, testSet,rep=1)
predNNET<- netOut$net.result

#scale back
predNNET<-predNNET*scale+min

plot(predNNET,regdataPost$ooF1D)
fit2<-lm(ooF1D ~ predNNET,data=regdataPost)
summary(fit2)



-- take avg. of 10 reps:
#############

# in-sample

meanFitIn<- apply(allFits,1,mean)
# scale back
meanFitIn<-meanFitIn*scale+min

plot(meanFitIn,regdataPre$ooF1D)
fit2<-lm(ooF1D ~ meanFitIn,data=regdataPre)
summary(fit2)


### out-sample

rep=90
allFitsOut= matrix(rep(0,rep*nrow(regdataPost)), ncol=rep)
for ( n in c(1:rep)) 
{
  netOut <- compute(net1, testSet,rep=n)
  predNNET<- netOut$net.result
  allFitsOut[,n]=predNNET
}

allFitsOut=as.data.frame(allFitsOut)

meanFit<- apply(allFitsOut,1,mean)
# scale back
meanFit<-meanFit*scale+min

plot(meanFit,regdataPost$ooF1D)
fit2<-lm(ooF1D ~ meanFit,data=regdataPost)
summary(fit2)

###############################
################################
###############################
################################



####################################
# first, save net2 into a file:
## to save best function into a file:
sink(file = "net2_weights.R")
#, append = TRUE)
net2$weights[[8]]
#cat("# This was a great function with a score of", theScore, "\n")
sink()

############## print to pdf
# net graph:
pdf("net2.pdf")
plot(net2,rep=8)
dev.off()

######## save R object
save(net2, file = "net2.Rdata")
#load("net2.Rdata")


###################################
################ how to use apply
computeNN <- function(data,c1)
#c1=GAP.1,HC.1,LC.1,AbsOO.3,AEMAOO)
{
   w11=c(0.2733936644, 0.2289574373, -0.1240974044, 0.1264358583, 0.8055110722, 0.6239024663)
   w12=c(0.44480447495, 0.20733749131, 0.24174221706, 0.20027865467, -0.10453279469, -0.09541666641)
   w13=c(-0.47994597881, -0.10133890386, 0.19321395667, -0.03886881265, -0.70791825966, -0.56342126833)
   w21=c(-0.6066483545, 1.2896109699, -0.3814766223, 1.6208484874)
   x=c(1,data[c1])
   o1=sigmoid(w11%*%x)
   o2=sigmoid(w12%*%x)
   o3=sigmoid(w13%*%x)
   x2=c(1,o1,o2,o3)
   yhat=w21%*%x2
   scale=6.2029486
   min=-3.1372293
   yhat*scale+min
}

##- function with extra args:
#     cave <- function(x, c1, c2) c(mean(x[c1]), mean(x[c2]))
#     apply(x, 1, cave,  c1 = "x1", c2 = c("x1","x2"))
     
NNTrain<- as.matrix(apply(trainSet,1,computeNN,c1=c("GAP.1","HC.1","LC.1","AbsOO.3","AEMAOO")),ncol=1)
NNTest<- as.matrix(apply(testSet,1,computeNN,c1=c("GAP.1","HC.1","LC.1","AbsOO.3","AEMAOO")),ncol=1)
#full set
NN<- as.matrix(apply(fullSet,1,computeNN,c1=c("GAP.1","HC.1","LC.1","AbsOO.3","AEMAOO")),ncol=1)
colnames(NN)=c("NN")

###########################################################




#####################################
#######################
## write it out to a file:

attach(regdata)

AEMAOO=round(AEMAOO,digit=8)
NN=round(NN,digit=8)


df= cbind(data.frame(SYM),DATE,ooF1D,GAP.1,HC.1,LC.1,AbsOO.3,AEMAOO,NN) 


#change numeric column to 7 digits
df=data.frame(lapply(df, function(y) if(is.numeric(y)) round(y, 8) else y)) 

write.table(df, file = "/home/jgeng/projects/FCASTDATA/NN.txt",  quote = FALSE, sep = " ",
            eol = "\n", na = "NA", dec = ".", row.names = FALSE,
            col.names = TRUE,  fileEncoding = "")

/home/jgeng/projects/FCASTDATA
###################################




###############################
########## regressions by quartiles
##################

# create X quartiles
regdata$X <- (regdata$OO2t6)
regdata$XQtr <- cut(regdata$X, c(-Inf, quantile(regdata$X, c(25,50,75,100)/100, na.rm =T) ))     
#table( regdata$XQtr)
 

regdata$X <- (regdata$OO2t6)
regdata$XQtr <- cut(regdata$X, c(-Inf, quantile(regdata$X, c(10,20,30,40,50,60,70,80,90,100)/100, na.rm =T) ))     
#table( regdata$XQtr)
 

fit2<-lm(F30M~GAP
:as.factor(XQtr)
,data=regdata)
summary(fit2)


##########################
#######################




fit1<-lm(difF1D ~ lag.1+ lag.2+ lag.3+ lag.4+ lag.5+ lag.6+ lag.7+ lag.8+ lag.9+ lag.10+ lag.11+ lag.12+ lag.13+ lag.14+ lag.15+ lag.16+ lag.17+ lag.18+ lag.19+ lag.20+ lag.21+ lag.22+ lag.23+ lag.24+ lag.25+ lag.26+ lag.27+ lag.28+ lag.29+ lag.30+ lag.31+ lag.32+ lag.33+ lag.34+ lag.35+ lag.36+ lag.37+ lag.38+ lag.39+ lag.40+ lag.41+ lag.42+ lag.43+ lag.44+ lag.45+ lag.46+ lag.47+ lag.48+ lag.49+ lag.50+ lag.51+ lag.52+ lag.53+ lag.54+ lag.55+ lag.56+ lag.57+ lag.58+ lag.59+ lag.60,data=regdata)
summary(fit1)


fit1<-lm(abs(difF1D) ~ abs(lag.1)+ abs(lag.2)+ abs(lag.3)+ abs(lag.4)+ abs(lag.5)+ abs(lag.6)+ abs(lag.7)+ abs(lag.8)+ abs(lag.9)+ abs(lag.10)+ abs(lag.11)+ abs(lag.12)+ abs(lag.13)+ abs(lag.14)+ abs(lag.15)+ abs(lag.16)+ abs(lag.17)+ abs(lag.18)+ abs(lag.19)+ abs(lag.20)+ abs(lag.21)+ abs(lag.22)+ abs(lag.23)+ abs(lag.24)+ abs(lag.25)+ abs(lag.26)+ abs(lag.27)+ abs(lag.28)+ abs(lag.29)+ abs(lag.30)+ abs(lag.31)+ abs(lag.32)+ abs(lag.33)+ abs(lag.34)+ abs(lag.35)+ abs(lag.36)+ abs(lag.37)+ abs(lag.38)+ abs(lag.39)+ abs(lag.40)+ abs(lag.41)+ abs(lag.42)+ abs(lag.43)+ abs(lag.44)+ abs(lag.45)+ abs(lag.46)+ abs(lag.47)+ abs(lag.48)+ abs(lag.49)+ abs(lag.50)+ abs(lag.51)+ abs(lag.52)+ abs(lag.53)+ abs(lag.54)+ abs(lag.55)+ abs(lag.56)+ abs(lag.57)+ abs(lag.58)+ abs(lag.59)+ abs(lag.60),data=regdata)
summary(fit1)



## ema:

attach(regdata)

# make_count.pl 1 60|gawk '{print "+a^"($1-1)"*abs(lag."$i")"}'|myTranspose.pl



a=0.86
emaLag<- a^0*abs(lag.1) +a^1*abs(lag.2) +a^2*abs(lag.3) +a^3*abs(lag.4) +a^4*abs(lag.5) +a^5*abs(lag.6) +a^6*abs(lag.7






a=0.915
#make_count.pl 1 60|gawk '{print "+a^"($1-1)}'|myTranspose.pl

denom<- a^0 +a^1 +a^2 +a^3 +a^4 +a^5 +a^6 +a^7 +a^8 +a^9 +a^10 +a^11 +a^12 +a^13 +a^14 +a^15 +a^16 +a^17 +a^18 +a^19 +a^20 +a^21 +a^22 +a^23 +a^24 +a^25 +a^26 +a^27 +a^28 +a^29 +a^30 +a^31 +a^32 +a^33 +a^34 +a^35 +a^36 +a^37 +a^38 +a^39 +a^40 +a^41 +a^42 +a^43 +a^44 +a^45 +a^46 +a^47 +a^48 +a^49 +a^50 +a^51 +a^52 +a^53 +a^54 +a^55 +a^56 +a^57 +a^58 +a^59

emaLagNorm<- emaLag/denom

plot(emaLagNorm,abs(regdata$difF1D))
fit1<-lm(abs(difF1D) ~ emaLagNorm,data=regdata)
summary(fit1)

######################
###
## set column width
## options(width=200)
## or put in .Rprofile
############################


## by year/YYYY


## by year for this period


## by year for this period
regdata$MMDD=regdata$DATE%%10000
regdata$YYYY=(regdata$DATE-regdata$MMDD) /10000
regdata$DD=regdata$DATE%%10000%%100
regdata$YYMM=(regdata$DATE-regdata$DD) /100
regdata$MM=(regdata$MMDD-regdata$DD)/100



regdata$YYQQ=regdata$YYMM
regdata$YYQQ=ifelse(regdata$MM==1|regdata$MM==2|regdata$MM==3,regdata$YYYY*100+3,regdata$YYQQ )
regdata$YYQQ=ifelse(regdata$MM==4|regdata$MM==5|regdata$MM==6,regdata$YYYY*100+6,regdata$YYQQ )
regdata$YYQQ=ifelse(regdata$MM==7|regdata$MM==8|regdata$MM==9,regdata$YYYY*100+9,regdata$YYQQ )
regdata$YYQQ=ifelse(regdata$MM==10|regdata$MM==11|regdata$MM==12,regdata$YYYY*100+12,regdata$YYQQ )



regdata$MOQ1=ifelse(regdata$MM==1|regdata$MM==4|regdata$MM==7|regdata$MM==10,1,0 )
regdata$MOQ2=ifelse(regdata$MM==2|regdata$MM==5|regdata$MM==8|regdata$MM==11,1,0 )
regdata$MOQ3=ifelse(regdata$MM==3|regdata$MM==6|regdata$MM==9|regdata$MM==12,1,0 )




# freq. counting: obs in each year
as.data.frame(table(regdata$YYYY))



fit1<-lm(abs(difF1D) ~ emaLag:as.factor(YYYY),data=regdata)
summary(fit1)



a=0.915


denom<- a^0 +a^1 +a^2 +a^3 +a^4 +a^5 +a^6 +a^7 +a^8 +a^9 +a^10 +a^11 +a^12 +a^13 +a^14 +a^15 +a^16 +a^17 +a^18 +a^19 +a^20 +a^21 +a^22 +a^23 +a^24 +a^25 +a^26 +a^27 +a^28 +a^29 +a^30 +a^31 +a^32 +a^33 +a^34 +a^35 +a^36 +a^37 +a^38 +a^39 +a^40 +a^41 +a^42 +a^43 +a^44 +a^45 +a^46 +a^47 +a^48 +a^49 +a^50 +a^51 +a^52 +a^53 +a^54 +a^55 +a^56 +a^57 +a^58 +a^59
emaLagNorm<- emaLag/denom


fit1<-lm(abs(difF1D) ~emaLagNorm+ I(emaLagNorm^4) ,data=regdata)
summary(fit1)


fit1<-lm(abs(difF1D) ~emaLagNorm+ I(lag.1^2)+I(lag.2^2) ,data=regdata)
summary(fit1)

fit1<-lm(abs(difF1D) ~emaLagNorm+ I(abs(lag.1)^4) ,data=regdata)
summary(fit1)


fit1<-lm(abs(difF1D) ~emaLagNorm+ I(abs(lag.1)^4)+I(abs(lag.2)^4)+I(abs(lag.3)^4) ,data=regdata)
summary(fit1)


a=0.5
emaLagO4<- a^0*abs(lag.1)^4 +a^1*abs(lag.2)^4 +a^2*abs(lag.3)^4 +a^3*abs(lag.4)^4 +a^4*abs(lag.5)^4 +a^5*abs(lag.6)^4 +a^6*abs(lag.7)^4

fit1<-lm(abs(difF1D) ~emaLagNorm+ emaLagO4 ,data=regdata)
summary(fit1)


########################### ACF, auto-cor

acf(regdata$ooP1D.0.95,lag.max=63,plot=FALSE)

###################################

########################
### add some local fit: LOESS

regdata$absDifF1D=abs(regdata$difF1D)


# fit a loess line
loess_fit <- loess(absDifF1D ~emaLagNorm, regdata)
loess_fit

lines(regdata$emaLagNorm, predict(loess_fit), col = "blue")

## very slow,
#############################


# fit a non-linear regression
nls_fit <- nls(absDifF1D ~ a + b * x^(-c), Data, start = list(a = 80, b = 20, 
    c = 0.2))
lines(Data$x, predict(nls_fit), col = "red")


library(lattice)
xyplot(regdata$absDifF1D~emaLagNorm, type=c("smooth", "p"))


##################
library(ggplot2)
ggplot(regdata, aes(emaLagNorm,absDifF1D),formula = ,absDifF1D ~emaLagNorm+emaLagNorm^2 ) + geom_point() + geom_smooth()

# quite fast
#  ?stat_smooth : use this to see how to use
#####

########################
# super smoother from Friedman
fitSS<-supsmu(emaLagNorm, regdata$absDifF1D, span = 0.5, periodic = FALSE, bass = 0)


#############################################
####################### spline smooth, fast

smoothingSpline = smooth.spline(emaLagNorm, regdata$absDifF1D, spar=0.5)
plot(emaLagNorm,regdata$absDifF1D,pch=".")

lines(smoothingSpline, col="red",lwd=3)

# vert fast, see below for parameter on line type/width etc
#http://www.statmethods.net/advgraphs/parameters.html

################################################

### hexbin plot, didn't try
set.seed(101)
a<-rnorm(1E7,1,1)
b<-rnorm(1E7,1,1)
library(hexbin)
system.time(plot(hexbin(a,b)))

## tabel plot package: visual inspection for large dataset, interesting, check it out later

Tableplot



################################################# speed up plotting points
# scatter plot, setting pch="." makes it faster;also if starting with X11(type="Xlib"), even faster
X11(type="Xlib")
plot(emaLagNorm,regdata$absDifF1D,pch=".")

## put something like this is your .Rprofile to customize the defaults
     setHook(packageEvent("grDevices", "onLoad"),
             function(...) grDevices::X11.options(width = 8, height = 6, xpos = 0,
                                                  pointsize = 10))


#plot(emaLagNorm,regdata$absDifF1D)
##########################################

# another scatter plot
ggplot(regdata,aes(x=emaLagNorm,y=absDifF1D),environment=environment() ) + geom_point(alpha = 0.4)



##################
#### 3D plot: RGL
library(rgl)
open3d()
 open3d(windowRect = c(00,00, 1000, 5760) )
plot3d(emaLagNorm, regdata$lag.1, regdata$absDifF1D, cex=1.5, size=4, type="s", col=rainbow(1000) )

## => too slow for big data, and crashed the R session.





###################
## all univariate R2s:
x <- regdata[4:68]
y <- regdata[3]
cor(x,y)^2





##############################
-- test 3D plot for y=x1*x2 or sphere 

x1<-seq(-1,1,0.05)
x2<-seq(-1,1,0.05)

f <- function(x1, x2) 
{ 
    #d=cbind(x1,x2)
    #z=sqrt(1-x1^2-x2^2)
    #x1*x2
    -x1*abs(x2)
}

#this Z must be a matrix
z <- outer(x1, x2, f)

#op <- par(bg = "white")
     persp(x1, x2, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue")

# rainbow color plot
library(shape)
persp(x1, x2, z, theta = -30, phi = 30, expand = 0.8, col = drapecol(z),
           ltheta = 60,  ticktype = "detailed",
           xlab = "OO.1", ylab = "OO.3", zlab = "ooF1D", scale = FALSE, main = "3D plot")


# plot to file
pdf("V3_5_8.pdf")
par(mfrow=c(2, 2))
.. here, run persp 
dev.off()


#######################################



#########################: this is best for x1:abs(x2) illustration
#######  another 3D with persp, but using fields to add a color bar

library(fields)

## persp example code
par(bg = "white")
x <- seq(-2, 2, length = 30)
y <- seq(-2, 2, length = 35)

# func=x*y
z <- outer(x, y, function(a, b) -a*abs(b))

nrz <- nrow(z)
ncz <- ncol(z)
# Create a function interpolating colors in the range of specified colors
jet.colors <- colorRampPalette( c("blue", "green","yellow", "red") )
# Generate the desired number of colors from this palette
nbcol <- 100
color <- jet.colors(nbcol)
# Compute the z-value at the facet centres
zfacet <- (z[-1, -1] + z[-1, -ncz] + z[-nrz, -1] + z[-nrz, -ncz])/4
# Recode facet z-values into color indices
facetcol <- cut(zfacet, nbcol)

#pdf("OO1_3_inter.pdf")

persp(x, y, z, col = color[facetcol], phi = 30, theta = -30, axes=T, ticktype='detailed',   xlab = "OO.1", ylab = "OO.3", zlab = "ooF1D",cex.lab=1.2,cex.axis=1.0)
#cex.lab: lable 20% larger than default

## add color bar
image.plot(legend.only=T, zlim=range(zfacet), col=color)

#dev.off()

#########################






###################################
#################################
### 3D wireframe example, with colarmap

library(lattice)

surf <-
expand.grid(x = seq(-pi, pi, length = 50),
            y = seq(-pi, pi, length = 50))

surf$z <-
with(surf, 
{
    #d <- 3 * sqrt(x^2 + y^2)
    #exp(-0.02 * d^2) * sin(d)
    #cicle: sqrt(1-x^2 - y^2)
    x*y
})

g <- surf

pts <-   data.frame(x =rbind(2,2,2), y=rbind(-2,-2,-2), z=rbind(.5,0,-.5))

wireframe(z ~ x * y, g, aspect = c(1, .5),
      drape=TRUE,
      scales = list(arrows = FALSE),
      pts = pts,
      panel.3d.wireframe =
      function(x, y, z,
               xlim, ylim, zlim,
               xlim.scaled, ylim.scaled, zlim.scaled,
               pts,
               ...) {
          panel.3dwire(x = x, y = y, z = z,
                       xlim = xlim,
                       ylim = ylim,
                       zlim = zlim,
                       xlim.scaled = xlim.scaled,
                       ylim.scaled = ylim.scaled,
                       zlim.scaled = zlim.scaled,
                       ...)
          xx <-
              xlim.scaled[1] + diff(xlim.scaled) *
                  (pts$x - xlim[1]) / diff(xlim)
          yy <-
              ylim.scaled[1] + diff(ylim.scaled) *
                  (pts$y - ylim[1]) / diff(ylim)
          zz <-
              zlim.scaled[1] + diff(zlim.scaled) *
                  (pts$z - zlim[1]) / diff(zlim)
          panel.3dscatter(x = xx,
                          y = yy,
                          z = zz,
                          xlim = xlim,
                          ylim = ylim,
                          zlim = zlim,
                          xlim.scaled = xlim.scaled,
                          ylim.scaled = ylim.scaled,
                          zlim.scaled = zlim.scaled,
                          ...)
      })



########################
##################################


##################################
### 3D plot with rgl with transpancy

library(rgl)
library(emdbook)

sfun <- function(x,y) 
{
  d <- 3 * sqrt(x^2 + y^2)
  exp(-0.02 * d^2) * sin(d)
  #d^3
  #x*y
  sqrt(3^2-x^2-y^2)
}

cc <- curve3d(sfun(x,y),xlim=c(-pi,pi),ylim=c(-pi,pi),n=c(50,50),sys3d="rgl")

colvec <- colorRampPalette(c("violet","blue","green","yellow","orange","red"))(100)
with(cc,persp3d(x,y,z,col=colvec[cut(z,100)],alpha=0.5))
pts <-   data.frame(x=c(2,2,2), y=c(-2,-2,-2), z=c(.5,0,-.5))
with(pts,spheres3d(x,y,z,col="blue",radius=0.1))
rgl.snapshot("rgltmp1.png")


#######################################
######################################



################################
## apply usage

A <- function(x) x + 1
wifi <- data.frame(replicate(9,1:4))
wifi

data.frame(wifi[1:3], apply(wifi[4:9],2, A) )
#or
cbind(wifi[1:3], apply(wifi[4:9],2, A) )

## sapply and lapply
If you want a list returned, use lapply. If you want a vector, use sapply.




#########################################
## 3D plot --perspective plot: this looks pretty good.

CH.sh allRets_all_diffAlphas.txt |fgrep P1D|myTranspose.pl| sed s/\ /,/g| sed s/ooP1D.//g

x1<-c(0.7,0.75,0.78,0.79,0.8,0.85,0.86,0.87,0.875,0.89,0.9,0.91,0.915,0.925,0.93,0.94,0.95,0.96,0.97,0.98,0.99,0.995,0.999,0.9999)

y1<-c(0.7,0.75,0.78,0.79,0.8,0.85,0.86,0.87,0.875,0.89,0.9,0.91,0.915,0.925,0.93,0.94,0.95,0.96,0.97,0.98,0.99,0.995,0.999,0.9999)

z<- cor(regdata[x],regdata[y])^2
#(Z is a matrix)


op <- par(bg = "white")
     #persp(x, y, z, theta = 30, phi = 30, expand = 0.5, col = "lightblue")


# rainbow color plot
library(shape)
persp(x1, y1, z, theta = 30, phi = 30, expand = 0.5, col = drapecol(z),
           ltheta = 120,  ticktype = "detailed",
           xlab = "ooP1D", ylab = "ooF1D", zlab = "R2" )




### to print to pdf file

pdf("R2_emaSpeed.pdf") 

persp(x1, y1, z, theta = 30, phi = 30, expand = 0.5, col = drapecol(z),
           ltheta = 120,  ticktype = "detailed",
           xlab = "ooP1D", ylab = "ooF1D", zlab = "R2", main="R2(ooF1D~ooP1D) for ema speeds" )

dev.off() 




(
# just regular single color plot
     persp(x1, y1, z, theta = 30, phi = 30, expand = 0.5, col = "grey",
           ltheta = 120, shade = 0.75, ticktype = "detailed",
           xlab = "ooP1D", ylab = "ooF1D", zlab = "R2" )

)
##################################################




###############################################
### plot multiple lines on same plot, with legends and title:



## simplifed R2:

y=0.875, 0.95, 0.99
x=all

y<- c(19,35,43)
x<- c(4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50)


x1<-c(0.7,0.75,0.78,0.79,0.8,0.85,0.86,0.87,0.875,0.89,0.9,0.91,0.915,0.925,0.93,0.94,0.95,0.96,0.97,0.98,0.99,0.995,0.999,0.9999)

 x1
 [1] 0.7000 0.7500 0.7800 0.7900 0.8000 0.8500 0.8600 0.8700 0.8750 0.8900
[11] 0.9000 0.9100 0.9150 0.9250 0.9300 0.9400 0.9500 0.9600 0.9700 0.9800
[21] 0.9900 0.9950 0.9990 0.9999

R2<-cor(regdata[x],regdata[y])^2



pdf("R2_emaSpeed_simple.pdf") 

plot(x1,R2[,1],ylim=c(0.0001,0.0007))
points(x1,R2[,2],col="red",pch=4)
points(x1,R2[,3],col="blue",pch=5)
legend(0.75, 0.0006, c("0.875", "0.95","0.99"), pch= c(1, 4,5),col=c("black","red","blue"))
title("R2(ooF1D~ooP1D) for ema speeds")

dev.off()



## for plot: in-R2 and out-R2
plot(allR2s$ns,allR2s$R2Ins,type="b",pch=1,lty=1,ylim=c(0.0,0.25))
lines(allR2s$ns,allR2s$R2Outs,type="b",pch=4,lty=4,col="red")
#legend(0.75, 0.0006, c("0.875", "0.95","0.99"), pch= c(1, 4,5),col=c("black","red","blue"))
#title("R2(ooF1D~ooP1D) for ema speeds")
# to see line type: ?plot.default.


##############################################







###################################################
# Stepwise Regression
library(MASS)

fit1<-lm(AOOF1 ~1
,data=regdata)
summary(fit1)

step <- stepAIC(fit1, scope=~.+AOO.ema.0.7+ AOO.ema.0.75+ AOO.ema.0.78+ AOO.ema.0.79+ AOO.ema.0.8+ AOO.ema.0.85+ AOO.ema.0.86+ AOO.ema.0.87+ AOO.ema.0.875+ AOO.ema.0.89+ AOO.ema.0.9+ AOO.ema.0.91+ AOO.ema.0.915+ AOO.ema.0.925+ AOO.ema.0.93+ AOO.ema.0.94+ AOO.ema.0.95+ AOO.ema.0.96+ AOO.ema.0.97+ AOO.ema.0.975+ AOO.ema.0.98+ AOO.ema.0.99+ AOO.ema.0.995+ AOO.ema.0.999+ AOO.ema.0.9999, direction="forward", data=regdata)

step$anova # display results 

##########################################

##########################
# All Subsets Regression
#####################
library(leaps)


leaps<-regsubsets(AOOF1~AOO.ema.0.7+ AOO.ema.0.75+ AOO.ema.0.78+ AOO.ema.0.79+ AOO.ema.0.8+ AOO.ema.0.85+ AOO.ema.0.86+ AOO.ema.0.87+ AOO.ema.0.875+ AOO.ema.0.89+ AOO.ema.0.9+ AOO.ema.0.91+ AOO.ema.0.915+ AOO.ema.0.925+ AOO.ema.0.93+ AOO.ema.0.94+ AOO.ema.0.95+ AOO.ema.0.96+ AOO.ema.0.97+ AOO.ema.0.975+ AOO.ema.0.98+ AOO.ema.0.99+ AOO.ema.0.995+ AOO.ema.0.999+ AOO.ema.0.9999
,data=regdata,nbest=5)

# view results
summary(leaps)

# list first 40 models coefs:
coef(leaps,1:40)

# plot Rsq
plot(summary(leaps)$rsq)

 [1] 0.2299512 0.2299224 0.2296747 0.2291102 0.2288321 0.2309530 0.2309066
 [8] 0.2308913 0.2308895 0.2308404 0.2310096 0.2310011 0.2309987 0.2309946
[15] 0.2309922 0.2310642 0.2310640 0.2310638 0.2310637 0.2310618 0.2310881
[22] 0.2310873 0.2310871 0.2310867 0.2310860 0.2311314 0.2311312 0.2311308
[29] 0.2311307 0.2311307 0.2311491 0.2311491 0.2311489 0.2311485 0.2311485
[36] 0.2311740 0.2311740 0.2311739 0.2311739 0.2311738


# plot a table of models showing variables in each model.
# models are ordered by the selection statistic.
plot(leaps,scale="r2")

# plot statistic by subset size
library(car)
subsets(leaps, statistic="rsq") 

# output matrix
#summary(leaps)$outmat


#######################################


##########  sort by value and return indices


### print top 20 best fitted functions
TOP=20
indices=sort.int(sapply(result1$population, result1$fitnessFunction),index.return = TRUE)
#indices has $ix and $i=x fields
#for (i in 1:length(indices$ix) )
for (i in 1:TOP )
{
  idx=indices$ix[i]
  print(paste("i=", i,"bestLoc=",idx,"fitness=",indices$x[i]) )
  print(result1$population[[idx]])
  cat("\n")
}

######################################
### insample and outsample type of tests
###
###
--## check in and out R2 as a function of iteration

## coefs for each iteration
maxIter=2000
allCoefs=data.frame(matrix(unlist(ga.OLS@bestSol), nrow=maxIter, byrow=T),stringsAsFactors=FALSE) 

# only sample some points
step=100
#max=2000%/%11
#1, 100, 200, etc
idx=seq(1,nrow(allCoefs),step)

idxs=rep(0,length(idx))
R2Ins=rep(0,length(idx))
R2Outs=rep(0,length(idx))

count=0;
for ( i in idx)
{
   count=count+1
   #print(i)

   
   ### in-sample
   coefs=ga.OLS@bestSol[[i]]
   yhat = coefs[1]+abs(coefs[2]*regdataPre$OO.1
                    +coefs[3]*regdataPre$OO.2
                    +coefs[4]*regdataPre$OO.3
                    +coefs[5]*regdataPre$OO.4
                    +coefs[6]*regdataPre$OO.5
                    +coefs[7]*regdataPre$OO.6
                    +coefs[8]*regdataPre$OO.7
                    +coefs[9]*regdataPre$OO.8
                    +coefs[10]*regdataPre$OO.9
                    +coefs[11]*regdataPre$OO.10) *regdataPre$OO.1*coefs[12]
   #plot(yhat,regdataPre$ooF1D,pch=".")
   fit1=lm(ooF1D ~ yhat,data=regdataPre)
   #summary(fit1)
   R2In=summary(fit1)$r.squared


   ### out-sample
   yhat = coefs[1]+abs(coefs[2]*regdataPost$OO.1
                    +coefs[3]*regdataPost$OO.2
                    +coefs[4]*regdataPost$OO.3
                    +coefs[5]*regdataPost$OO.4
                    +coefs[6]*regdataPost$OO.5
                    +coefs[7]*regdataPost$OO.6
                    +coefs[8]*regdataPost$OO.7
                    +coefs[9]*regdataPost$OO.8
                    +coefs[10]*regdataPost$OO.9
                    +coefs[11]*regdataPost$OO.10) *regdataPost$OO.1*coefs[12]
   #plot(yhat,regdataPost$ooF1D,pch=".")
   fit1=lm(ooF1D ~ yhat,data=regdataPost)
   #summary(fit1)
   R2Out=summary(fit1)$r.squared

   idxs[count]=i
   R2Ins[count]=R2In
   R2Outs[count]=R2Out
   print(paste("i, R2in/out=",i,R2In, R2Out)) 
}


## for plot: in-R2 and out-R2
plot(idxs,R2Ins,type="b",pch=1,lty=1,ylim=c(0.0,0.02))
lines(idxs,R2Outs,type="b",pch=4,lty=4,col="red")
#legend(0.75, 0.0006, c("0.875", "0.95","0.99"), pch= c(1, 4,5),col=c("black","red","blue"))
#title("R2(ooF1D~ooP1D) for ema speeds")
# to see line type: ?plot.default.

######################################
######################################







